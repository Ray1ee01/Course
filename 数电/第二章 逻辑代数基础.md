# 第二章 逻辑代数基础

[toc]

## 2.1 概述

## 2.2 逻辑代数中的三种基本运算

**异或：**$A\oplus B=A·B'+A'·B$

**同或：**$A\odot B=A·B+A'·B'$

**两者互为反运算**

## 2.3逻辑代数的基本公式和常用公式

$$
\begin{align}
产生同类项（极小项变极大项）A+B\cdot C&=(A+B)\cdot(A+C)\\
当（A与A'）同时出现：A+A'B&=A+B \\
最小原则：A\cdot (A+B)&=A\\
当（A与A'）同时出现：A\cdot B+A'\cdot C+B\cdot C&=A\cdot B+A'\cdot C\\
当（A与A'）同时出现：A\cdot B+A'\cdot C+BCD&=A\cdot B+A'\cdot C\\

\end{align}
$$

## 2.4 逻辑代数的基本定理

### 2.4.1 代入定理

### 2.4.2 反演定理

Y$\longrightarrow$且并对换，01对换，变量取反$\longrightarrow$Y'

### 2.4.3 对偶定理

Y$\longrightarrow$且并对换，01对换$\longrightarrow$Y$^D$

若两个逻辑式相等，其对偶式也相等。

## 2.5 逻辑函数及其描述方法

### 2.5.1 逻辑函数

### 2.5.2 逻辑函数的描述方法

#### 一、真值表

#### 二、逻辑函数式

#### 三、逻辑图

#### 四、波形图

#### 五、各种描述方法间的相互转换

1. **真值表转逻辑函数式**：
   1. 极小项之和
   2. 极大项之积

2. **逻辑图转逻辑表达式：**
3. **波形图转真值表**

### 2.5.3 逻辑函数的两种标准形式

#### 一、最小项与最大项

1. 最小项：反对应0
2. 最大项：反对应1

#### 二、逻辑函数的最小项之和形式

- 将逻辑函数转化为最小项形式：离散学的方法

#### 三、逻辑函数的最大项之积形式

- 将逻辑函数转化为最大项形式：利用公式$A+BC=(A+B)(A+C)$与（$AA'=0$）（可以不用）化成乘积式，再利用类似于上面的方法。注意这里最大项的反对应1
- 最大项转最小项\最小项转最大项：直接取余（$\Sigma _m(0,2)=\Pi_M (1,3)$）

## 2.6 逻辑函数的化简方法

### 2.6.1 公式化简法

#### 一、并项法

- $AB+AB'=A$

#### 二、吸收法

- $A+AB=A$

#### 三、消项法

- $AB+A'C+BC=AB+A'C$
- $AB+A'C+BCD=AB+AC'$

#### 四、消因子法

- $A+A'B=A+B$

#### 五、配项法

- $A+A=A$
- $(A'+A)=1$

### 2.6.2 卡诺图化简法***

#### 一、逻辑函数的卡诺图表示法

- 逻辑函数转卡诺图：化成最小项之和，再画图。
- 卡诺图转逻辑函数：直接写

#### 二、用卡诺图化简逻辑函数

1. 合并最小项的原则

   若两个最小项相邻，则可合并为一项并消去一对因子。合并后的结果只剩公共因子。

   若四个最小项相邻并排成一个矩形，则可合并为一项并消去两对因子。

   ....

   若有$2^n$个最小项相邻，则可合并

2. 卡诺图化简法的步骤
   1. 将函数化为最小项之和
   2. 画出表示该逻辑函数的卡诺图
   3. 找出可以合并的最小项
   4. 选取化简后的乘积项。选取的原则是：
      1. 这些乘积项应包含函数式中所有的最小项（**应覆盖卡诺图中所有的1**）
      2. 所用的乘积项数目最少。也就是可合并的最小项组成的**矩形组数目最小**
      3. 每个乘积项所包含的因子最少，也就是每个可合并的**最小项矩形组中应包含尽量多的最小项**。

3. **注意**：
   1. 最小项可以**重复使用**。
   
2. 卡诺图中，所有1的部分是$Y$，则所有0的部分是$Y'$，因此可以先合并0再求反。
   
   3. 如果需要将函数化简为最简的**与或非**式，采用合并0的方式最合适
   
      P.S. 与或非式：$(AB+CD)'$
   
   4. 化简之后可以用**公式法验证**一下是否是最简式
   5. 找到一个没有被划进去的点，给它寻找覆盖的时候，**不要管其他点的标记**，能划多大就划多大。

### 2.6.3 补充：卡诺图之间的运算

- $Y_1\cdot Y_2=\Sigma m_{i1}\cdot m_{i2}$，最小项相乘
- $Y_1+Y_2=\Sigma m_{i1}+\Sigma m_{i2}$，最小项相加
- $Y_1\oplus Y_2=\Sigma m_{i1}\oplus m_{i2}$，最小项取异或
- $Y_1\odot Y_2=\Sigma m_{i1}\odot m_{i2}$，最小项取同或
- 注意：在卡诺图运算中，无关项可以作为逻辑1，也可以作为逻辑0，在对无关项做运算的时候，只有在取0或1都不能保留（逻辑运算结果为0）的情况下才把无关项删去。否则就保留无关项。

## 2.7 具有无关项的逻辑函数及其化简

### 2.7.1 约束项、任意项和逻辑函数式中的无关项

#### 约束项

当输入变量的取值不是任意的，称为**约束**。把这一组输入变量称为具有约束的一组逻辑变量。

由于每一组输入变量的取值都使一个、而且仅有一个最小项的值为1，所以当某些输入变量的取值不能出现时，可以用他们对应的最小项恒等于0来表示。例如
$$
\left\{
\begin{align}
&A'B'C=0\\
&A'BC'=0\\
&A'BC=0\\
&AB'C=0
\end{align}
\right.
$$

或写作
$$
A'B'C+A'BC'+A'BC+AB'C=0
$$
将这些**恒等于0的最小项称为约束项**。

#### 任意项

在输入变量的某些取值下，函数值是1还是0皆可，并不影响电路的功能。在这些变量取值下，**其值等于1的那些最小项称为任意项**。

存在任意项的逻辑函数也叫不完全定义的逻辑函数。

- 约束项与任意项的区别：
  - 约束项是在正常工作下绝对不可能出现（=1）的逻辑值
  - 任意项是可能出现（=1）的逻辑值，但当任意项出现时，会破坏正常工作。（一切以任意项优先）？

### 2.7.2 无关项在化简逻辑函数中的应用

合并最小项时，究竟是把卡诺图中的x作为1还是作为0来看待，应该以得到的相邻最小项**矩形组合最大**，而且**矩形数目最少**为原则。

（能用的就用，不能用的就不管了）

## 2.8 多输出逻辑函数的化简

有时候在化简多输出函数的时候，**不用把每个输出函数都化成最简式**，如果能**找到他们的公共项**，就可以在连接电路时更简单。

## 2.9 逻辑函数形式的变换

1. **与或$\rightarrow$与非-与非**：**两次求反**

2. **与或$\rightarrow$与或非**：**加非，里面变一层，然后分配律** or **卡诺图合并0**
3. **与或$\rightarrow$或与**：先化成**与或非，再摩根定律**（最外层的非号要拆进去）

4. **与或$\rightarrow$或非-或非**：先化成**与或非，再摩根定律**（不动最外层的非号，里面的与式自己变）（与上面的区别在于最外层的非号拆不拆进去）

## 作业中考察的知识点：

1. 真值表$\rightarrow$逻辑函数式
2. 电路$\rightarrow$逻辑函数式
3. 波形图$\rightarrow$逻辑函数式
4. 化为最小项之和
5. 化为最大项之积
6. 公式法化简
7. 公式法化简为最简与或式
8. 卡诺图$\rightarrow$逻辑函数式
9. 卡诺图化简为最简与或式
10. 函数式化简（卡诺图or公式法）
11. 电路$\rightarrow$逻辑函数式$\rightarrow$最简与或式
12. 约束项逻辑函数化简
13. 无关项逻辑函数化简
14. 卡诺图之间的运算